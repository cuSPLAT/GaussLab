// model.cpp
#include <ATen/core/interned_strings.h>
#include <cstdio>
#include <cstring>
#include <filesystem>
#include <fstream>
#include "includes/model.hpp"
#include "includes/dicom_loader.hpp"
#include <thread>
#include <omp.h>

namespace fs = std::filesystem;

const double C0 = 0.28209479177387814;
torch::Tensor rgb2sh(const torch::Tensor &rgb)
{
    // Converts from RGB values [0,1] to the 0th spherical harmonic coefficient
    return (rgb - 0.5) / C0;
}

SceneBE createSceneFromPlyData(const PlyData& data)
{
    SceneBE scene;

    scene.verticesCount = data.means.size(0);
    if (scene.verticesCount == 0) { return scene; }
    int32_t dcF = data.featuresDc.size(1);

    // --- 1) Calculate Centroid ---
    torch::Tensor centroidTensor = torch::mean(data.means, /*dim=*/0);
    memcpy(scene.centroid, centroidTensor.data_ptr<float>(), 3 * sizeof(float));

    // --- 2) Prepare for buffer creation ---
    size_t floats_per_pt = 3  /*xyz*/ + 3 /*colors*/
                          + 1 /*opacity*/ + 3 /*scale*/ + 4 /*quat*/;
    size_t record_bytes = floats_per_pt * sizeof(float);
    scene.bufferSize = record_bytes * scene.verticesCount;
    // Allocate the single, contiguous buffer
    scene.sceneDataBuffer = std::make_unique<float[]>(floats_per_pt * scene.verticesCount);
    // TODO: there is no need to re-init but for some reason it errors
    // most probably an include mismatch
    torch::Tensor scales = torch::exp(data.scales);
    torch::Tensor opacities = 1 / (1 + torch::exp(-data.opacities));

    // --- 3) Get raw data pointers from CPU tensors once ---
    const float* means_ptr     = data.means.data_ptr<float>();
    const float* features_ptr  = data.featuresDc.data_ptr<float>();
    const float* opacities_ptr = opacities.data_ptr<float>();
    const float* scales_ptr    = scales.data_ptr<float>();
    const float* quats_ptr     = data.quats.data_ptr<float>();

    size_t current_offset = 0;
    std::memcpy(
        scene.sceneDataBuffer.get() + current_offset, means_ptr, data.means.size(0) * 3 * sizeof(float)
    );
    current_offset += data.means.size(0) * 3;
    std::memcpy(
        scene.sceneDataBuffer.get() + current_offset, features_ptr, data.featuresDc.size(0) * 3 * sizeof(float)
    );
    current_offset += data.featuresDc.size(0) * 3;
    std::memcpy(
        scene.sceneDataBuffer.get() + current_offset, opacities_ptr, data.opacities.size(0) * sizeof(float)
    );
    current_offset += data.opacities.size(0);
    std::memcpy(
        scene.sceneDataBuffer.get() + current_offset, scales_ptr, data.scales.size(0) * 3 * sizeof(float)
    );
    current_offset += data.scales.size(0) * 3;
    std::memcpy(
        scene.sceneDataBuffer.get() + current_offset, quats_ptr, data.quats.size(0) * 4 * sizeof(float)
    );

    return scene;
}

PlyData Model::getPlyData()
{
    PlyData data;
    data.means      = means.cpu();
    data.featuresDc = featuresDc.cpu();
    data.opacities  = opacities.cpu();
    data.scales     = scales.cpu();
    data.quats      = quats.cpu();
    return data;
}

void savePly(const std::string &filename, const PlyData& data)
{
    SceneBE scene = createSceneFromPlyData(data);

    if (scene.verticesCount == 0)
    {
        std::cerr << "Warning: Attempting to save an empty scene." << std::endl;
        return;
    }
    int32_t dcF = data.featuresDc.size(1);

    // ASCII header
    std::ostringstream hdr;
    hdr << "ply\n"
        << "format binary_little_endian 1.0\n"
        << "comment Generated by cusplat medical pipeline\n"
        << "comment centroid_x " << scene.centroid[0] << "\n"
        << "comment centroid_y " << scene.centroid[1] << "\n"
        << "comment centroid_z " << scene.centroid[2] << "\n"
        << "element vertex " << scene.verticesCount << "\n" // Uses scene.verticesCount
        << "property float x\nproperty float y\nproperty float z\n"
        << "property float nx\nproperty float ny\nproperty float nz\n";
    for (int i = 0; i < dcF;   ++i) hdr << "property float f_dc_"   << i << "\n";
    hdr << "property float opacity\n"
        << "property float scale_0\nproperty float scale_1\nproperty float scale_2\n"
        << "property float rot_0\nproperty float rot_1\nproperty float rot_2\nproperty float rot_3\n"
        << "end_header\n";

    std::ofstream o(filename, std::ios::binary);
    auto const &hs = hdr.str();
    o.write(hs.data(), hs.size());
    o.write(reinterpret_cast<const char*>(scene.sceneDataBuffer.get()), scene.bufferSize);
    o.close();
    std::cout << "Wrote " << filename << std::endl;
}
